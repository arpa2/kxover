#!/usr/bin/env python
#
# pypeline builds a pipeline of network units, and keeps an eye on
# their successful termination.  It allows quick testing setups with
# an input stage in Python, an intermediate program run in a (portable)
# subprocess, and finally an output stage in Python.  The Python units
# run as threads and are usually called with a set of arguments, in
# the style of argv[1:].
#
# Specify commands and arguments on the pypeline command line; "--"
# separates the various commands.  They are started in turn, and
# each must output "--\n" after it has finished completion (and is
# ready for interaction).  Furthermore, there may be port numbers,
# allocated dynamically when they are specified as "TCP:<key>" or
# "UDP:<key>" or "SCTP:<key>" where the "<key>" is a string to
# identify the same port (which may be empty).  A fresh port is then
# allocated from the ephemeral space, and its number is passed to
# the subprocesses as a commandline argument in that position.
#
# From: Rick van Rein <rick@openfortress.nl>


import sys
import time

import socket
import threading
import subprocess 
# import optparse


if not '--' in sys.argv or sys.argv [1] == '--' or sys.argv [-1] == '--':
    sys.stderr.write ('Usage: %s cmd1 arg1a arg1b -- cmd2 arg2a -- cmd3 arg3a arg3b\n' % (sys.argv [0],))
    sys.exit (1)


prox = [ [] ]

soxtypes = {
    'TCP:':  (socket.AF_INET, socket.SOCK_STREAM,    0),
    'UDP:':  (socket.AF_INET, socket.SOCK_DGRAM,     0),
    'SCTP:': (socket.AF_INET, socket.SOCK_SEQPACKET, 0),
}

myip = socket.gethostbyname (socket.gethostname ())
port_alloc = { }

for argi in sys.argv [1:]:
    proto = argi [:1+argi.find (':')]
    if argi == '--':
        prox.append ( [] )
    elif soxtypes.has_key (proto):
        if not port_alloc.has_key (argi):
            sox = socket.socket ( *soxtypes [proto] )
            sox.bind ( (myip, 0) )
            port = str (sox.getsockname () [1])
            sox.close ()
            port_alloc [argi] = port
        prox [-1].append (port_alloc [argi])
    else:
        prox [-1].append (argi)

class SyncedProcess (threading.Thread):

    def __init__ (self, argv):
        threading.Thread.__init__ (self)
        self.proc = subprocess.Popen (
                        argv,
                        stdin=None,
                        stdout=subprocess.PIPE,
                        stderr=sys.stderr,
                        universal_newlines=True)
        self.sofar = ''
        self.name = argv [0].split ('/') [-1]
        self.copyloop ('--\n')

    def copyloop (self, terminator):
        nextln = None
        while nextln != terminator:
            nextln = self.proc.stdout.readline ()
            if nextln != terminator:
                sys.stdout.write ('%s: %s' % (self.name, nextln))
            self.sofar += nextln

    def run (self):
        self.copyloop ('')

    def final_result (self):
        self.join ()
        self.proc.wait ()
        return self.proc.returncode

syncprox = []
for proc in prox:
    sys.stdout.write ('pypeline: initial: %r\n' % (proc,))
    newsyncer = SyncedProcess (proc)
    syncprox.append (newsyncer)
    sys.stdout.write ('pypeline: freerun: %r\n' % (proc,))
    newsyncer.start ()

exitval = 0
for (sync,proc) in zip (syncprox,prox):
    result = sync.final_result ()
    sys.stdout.write ('pypeline: results: %r --> %r\n' % (proc, result))
    if result != 0:
        sys.stderr.write ('Exit code %d from process %r\n' % (result, proc))
        exitval = 1
sys.exit (exitval)

