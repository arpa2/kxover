#!/usr/bin/env python
#
# pypeline builds a pipeline of network units, and keeps an eye on
# their successful termination.  It allows quick testing setups with
# an input stage in Python, an intermediate program run in a (portable)
# subprocess, and finally an output stage in Python.  The Python units
# run as threads and are usually called with a set of arguments, in
# the style of argv[1:].
#
# From: Rick van Rein <rick@openfortress.nl>


import sys
import time

import subprocess 
# import optparse


if not '--' in sys.argv or sys.argv [1] == '--' or sys.argv [-1] == '--':
    sys.stderr.write ('Usage: %s cmd1 arg1a arg1b -- cmd2 arg2a -- cmd3 arg3a arg3b\n' % (sys.argv [0],))
    sys.exit (1)


procs = [ [] ]

for argi in sys.argv [1:]:
    if argi == '--':
        procs.append ( [] )
    else:
        procs [-1].append (argi)

procobj = []
for argvi in procs:
    print 'Starting', argvi
    procobj.append (subprocess.Popen (argvi,
                stdin=None,
                stdout=sys.stdout,
                stderr=sys.stderr,
                universal_newlines=True))
    print 'Started ', argvi

exitval = 0
for poi in range (len (procobj)):
    po = procobj [poi]
    po.wait ()
    if po.returncode != 0:
        sys.stderr.write ('Exit code %d from process %r\n' % (po.returncode, procs [poi]))
        exitval = 1
sys.exit (exitval)

