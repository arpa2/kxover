#!/usr/bin/env python
#
# pypeline builds a pipeline of network units, and keeps an eye on
# their successful termination.  It allows quick testing setups with
# an input stage in Python, an intermediate program run in a (portable)
# subprocess, and finally an output stage in Python.  The Python units
# run as threads and are usually called with a set of arguments, in
# the style of argv[1:].
#
# Specify commands and arguments on the pypeline command line; "--"
# separates the various commands.  They are started in turn, and
# each must output "--\n" after it has finished completion (and is
# ready for interaction).  Furthermore, there may be port numbers,
# allocated dynamically when they are specified as "TCP:<key>" or
# "UDP:<key>" or "SCTP:<key>" where the "<key>" is a string to
# identify the same port (which may be empty).  A fresh port is then
# allocated from the ephemeral space, and its number is passed to
# the subprocesses as a commandline argument in that position.  In
# a similar fashion, there can be "IP:<key>" to specify the local
# host as an IP address.
#
# From: Rick van Rein <rick@openfortress.nl>


import sys
import time

import socket
import signal
import threading
import subprocess 
# import optparse


if not '--' in sys.argv or sys.argv [1] == '--' or sys.argv [-1] == '--':
    sys.stderr.write ('Usage: %s cmd1 arg1a arg1b -- cmd2 arg2a -- cmd3 arg3a arg3b\n' % (sys.argv [0],))
    sys.exit (1)


prox = [ [] ]
zigz = [ [] ]

soxtypes = {
    'TCP:':  (socket.AF_INET, socket.SOCK_STREAM,    0),
    'UDP:':  (socket.AF_INET, socket.SOCK_DGRAM,     0),
    'SCTP:': (socket.AF_INET, socket.SOCK_SEQPACKET, 0),
}

sigtypes = signal.SIGHUP

myip = socket.gethostbyname (socket.gethostname ())
port_alloc = { }

for argi in sys.argv [1:]:
    proto = argi [:1+argi.find (':')]
    if argi == '--':
        prox.append ( [] )
        zigz.append ( [] )
    elif proto == 'SIG:':
        signame = argi [:3] + argi [4:]
        signum = getattr (signal, signame, None)
        if type (signum) != int:
            sys.stderr.write ('No signal named %s is known' % (signame,))
            sys.exit (1)
        zigz [-1].append ( (signame,signum) )
        prox [-1].append (str (signum))
    elif proto == 'IP:':
        prox [-1].append (myip)
    elif soxtypes.has_key (proto):
        if not port_alloc.has_key (argi):
            sox = socket.socket ( *soxtypes [proto] )
            sox.bind ( (myip, 0) )
            port = str (sox.getsockname () [1])
            sox.close ()
            port_alloc [argi] = port
        prox [-1].append (port_alloc [argi])
    else:
        prox [-1].append (argi)

class SyncedProcess (threading.Thread):

    def __init__ (self, argv, signals=[]):
        threading.Thread.__init__ (self)
        self.error = None
        self.signals = signals
        self.proc = subprocess.Popen (
                        argv,
                        stdin=None,
                        stdout=subprocess.PIPE,
                        universal_newlines=True)
        self.sofar = ''
        if 'python' in argv [0]:
            self.name = argv [1].split ('/') [-1]
        else:
            self.name = argv [0].split ('/') [-1]
        self.copyloop ('--\n')

    def copyloop (self, terminator):
        nextln = None
        while nextln != terminator:
            nextln = self.proc.stdout.readline ()
            if nextln != terminator:
                if nextln == '':
                    sys.stderr.write ('Program output ended before marker "%s"\n' % (terminator.strip (),))
                    self.error = 1
                    return
                sys.stdout.write ('%s: %s' % (self.name, nextln))
            self.sofar += nextln

    def run (self):
        self.copyloop ('')

    def could_signal (self):
        return self.signals != []

    def send_signals (self):
        if self.proc.returncode is not None:
            return
        for (signame,signum) in self.signals:
            sys.stdout.write ('%s: Sending signal %s\n' % (self.name, signame))
            self.proc.send_signal (signum)

    def initial_result (self):
        # Result code or None
        self.join (0.0)
        if not self.isAlive ():
            return None
        self.proc.poll ()
        return self.proc.returncode


    def final_result (self):
        self.join ()
        if self.proc.returncode is None:
            self.proc.wait ()
        return self.error or self.proc.returncode

syncprox = []
for (proc,zig) in zip (prox,zigz):
    sys.stdout.write ('pypeline: initial: %r\n' % (proc,))
    newsyncer = SyncedProcess (proc,signals=zig)
    syncprox.append (newsyncer)
    sys.stdout.write ('pypeline: freerun: %r\n' % (proc,))
    newsyncer.start ()

# End Game #1.  Wait for SyncedProcesses that cannot be signaled to stop
for sync in syncprox:
    if not sync.could_signal ():
        result = sync.final_result ()

# End Game #2.  Signal all remaining SyncedProcesses that they may stop
for sync in syncprox:
    if sync.could_signal ():
        sync.send_signals ()

# End Game #3.  Wait until all SyncedProcesses have stopped and conclude.
exitval = 0
for (sync,proc) in zip (syncprox,prox):
    result = sync.final_result ()
    sys.stdout.write ('pypeline: results: %r --> %r\n' % (proc, result))
    if result != 0:
        sys.stderr.write ('Exit code %d from process %r\n' % (result, proc))
        exitval = 1
sys.exit (exitval)

