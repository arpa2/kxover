#!/usr/bin/env python
#
# pypeline builds a pipeline of network units, and keeps an eye on
# their successful termination.  It allows quick testing setups with
# an input stage in Python, an intermediate program run in a (portable)
# subprocess, and finally an output stage in Python.  The Python units
# run as threads and are usually called with a set of arguments, in
# the style of argv[1:].
#
# From: Rick van Rein <rick@openfortress.nl>


import sys
import time

import threading
import subprocess 
# import optparse


if not '--' in sys.argv or sys.argv [1] == '--' or sys.argv [-1] == '--':
    sys.stderr.write ('Usage: %s cmd1 arg1a arg1b -- cmd2 arg2a -- cmd3 arg3a arg3b\n' % (sys.argv [0],))
    sys.exit (1)


prox = [ [] ]

for argi in sys.argv [1:]:
    if argi == '--':
        prox.append ( [] )
    else:
        prox [-1].append (argi)

class SyncedProcess (threading.Thread):

    def __init__ (self, argv):
        threading.Thread.__init__ (self)
        self.proc = subprocess.Popen (
                        argv,
                        stdin=None,
                        stdout=subprocess.PIPE,
                        stderr=sys.stderr,
                        universal_newlines=True)
        self.sofar = ''
        self.name = argv [0].split ('/') [-1]
        self.copyloop ('--\n')

    def copyloop (self, terminator):
        nextln = None
        while nextln != terminator:
            nextln = self.proc.stdout.readline ()
            if nextln != terminator:
                sys.stdout.write ('%s: %s' % (self.name, nextln))
            self.sofar += nextln

    def run (self):
        self.copyloop ('')

    def final_result (self):
        self.join ()
        self.proc.wait ()
        return self.proc.returncode

syncprox = []
for proc in prox:
    sys.stdout.write ('pypeline: initial: %r\n' % (proc,))
    newsyncer = SyncedProcess (proc)
    syncprox.append (newsyncer)
    sys.stdout.write ('pypeline: freerun: %r\n' % (proc,))
    newsyncer.start ()

exitval = 0
for (sync,proc) in zip (syncprox,prox):
    result = sync.final_result ()
    sys.stdout.write ('pypeline: results: %r --> %r\n' % (proc, result))
    if result != 0:
        sys.stderr.write ('Exit code %d from process %r\n' % (result, proc))
        exitval = 1
sys.exit (exitval)

