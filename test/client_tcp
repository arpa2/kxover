#!/usr/bin/env python
#
# Fake a client by connecting to a given TCP port on localhost and
# sending literal files, expecting other literal files in return.
#
# Fake a TLS client by connecting to a given TCP port on localhost and
# sending literal files, expecting other literal files in return.  But
# before doing anything else, make a STARTTLS handshake.  This is still
# fake TLS, so nothing but this handshake will happen.
#
# This is useful for testing purposes.
#
# The files contain the binary content of pairs of a request and response.
# Instead of a request file, specify "-" to skip sending; instead of a
# response file, specify "-" to accept any response.  An odd number of
# files will mean that the last request is sent but no response will
# be expected.
#
# The program times out after 10 seconds of waiting for a request.
#
# You can start this program from C with system("./fakekdc x y z &");
#
# From: Rick van Rein <rick@openfortress.nl>

import sys
import time
import struct

import socket

import optparse

parser = optparse.OptionParser ()
parser.add_option ('--fake-tls', dest='fake_tls', action='store_true', default=False,
            help='Start TCP interaction with a TLS handshake but skip the actual TLS handshake')
(options,args) = parser.parse_args ()

if len (args) < 3:
    sys.stderr.write ('Usage: ' + sys.argv [0] + ' [--fake-tls] <ip> <port> req1.bin rep1.bin req2.bin rep2.bin...\n')
    sys.exit (1)

myip = args [0]
try:
    port = int (args [1])
    if not 0 < port <= 65535:
        raise Exception ('kul')
except:
    sys.stderr.write ('%s expected a port number, not: %r\n' % (sys.argv [0], args [1]))
    sys.exit (1)

sox = socket.socket (socket.AF_INET, socket.SOCK_STREAM, 0)
sox.setblocking (True)
sox.settimeout (10.0)
peer = (myip, port)
sox.connect (peer)
print 'sending to %r' % (peer,)
print '--'
sys.stdout.flush ()

if options.fake_tls:
    tls_flags = struct.pack ('>I', 0x80000001)
    sox.send (tls_flags)
    tls_adopt = sox.recv (4)
    assert len (tls_adopt) == 4, 'Got not 4 but %d bytes for tls_adopt' % (len (tls_adopt),)
    tls_adopt = struct.unpack ('>I', tls_adopt) [0]
    assert tls_adopt == 0x00000000, 'Got 0x%08x instead of 0x00000000 as tls_adopt' % (tls_adopt,)

sending = True
for argi in args [2:]:
    if argi == '-':
        data = None
    else:
        data = open (argi, 'r').read ()
    if not sending:
        sys.stdout.write ('Receiving for %r\n' % (argi,))
        try:
            reqlen0 = reqlen = sox.recv (4)
            assert len (reqlen) == 4, 'Got not 4 but %d bytes for reqlen' % (len (reqlen),)
            reqlen = struct.unpack ('>I', reqlen) [0]
            req = sox.recv (reqlen)
            assert len (req) == reqlen, 'Got not %d but %d bytes for req' % (len (req), reqlen)
        except socket.timeout:
            sys.stderr.write ('Timed out in %s\n' % (sys.argv [0],))
            sox.close ()
            sys.exit (1)
        if data is not None and req != data:
            sys.stderr.write ('Request data not as expected\n')
            sox.close ()
            sys.exit (1)
    else:
        sys.stdout.write ('Sending for %r\n' % (argi,))
        if data is not None:
            datalen = struct.pack ('>I', len (data))
            sox.send (datalen)
            sox.send (data)
    sending = not sending

sox.close ()
sys.exit (0)

