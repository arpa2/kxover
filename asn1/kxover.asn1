-- # Impromptu Realm Crossover for Kerberos (KXOVER)
--
-- > *We sometimes want to connect KDCs that are hitherto unknown, for instance
-- > because they are randomly operated realms on the Internet, and a user in one
-- > realm wants to approach a service managed in another.  To do this, we need
-- > an exchange called KXOVER below.*

-- The KXOVER or `KX` exchange consists of a `KX-REQ` request message and a `KX-REP`
-- reply message.  In each, there is a certificate-based signature over an ECDH public
-- key offer.  These offers combine to form a shared key that serves as a
-- realm crossover key to be stored on each end with an identity like
-- `krbtgt/SERVICE.REALM@CLIENT.REALM`, where the `SERVICE.REALM` and `CLIENT.REALM`
-- are taken from the exchange.


-- ## Modified KDC request/response messages

-- We have created a proof-of-concept for Impromptu Realm Crossover based on an
-- `AS` exchange with PKINIT between KDCs.  We found a few problems with this
-- approach, which is the reason that we are proposing an alternative KXOVER exchange
-- below:
--
--   * The messages are not an exact match for key agreement.  Most notably,
--     the `AS-REP` message must contains a `ticket` and an `enc-part` which
--     are meaningless when establishing a crossover key between KDCs.
--
--   * Overloading of existing messages is more at danger of causing confusion in
--     various network components, possible even with security risks implied, than
--     fresh message types.
--
--   * Routing was not entirely logical.  The KDC has places where it can decide
--     to send off traffic, but this is at a later moment in time than routing
--     the messages to a backend daemon for KXOVER.  By using other messages, it
--     is possible to separate this (relatively slow) daemon from the core KDC,
--     and distribute the messages at a message-type-based routing stage inside
--     the KDC.

-- Unlike clients, which share a secret with their KDC that protects their traffic,
-- there is no such prior security relation between two random KDCs.  To
-- establish trust, we use a variation on DANE, where the declaration of the KDC
-- in terms of SRV records in DNS is used to locate the port and transport for
-- the KDC, which is in turn used to lookup a TLSA record that provides validation
-- information for certificates that are authoritative for the realm.  It is such
-- a certificate that must be used to sign a `KX-REQ` as well as a `KX-REP` message,
-- each by their respective sender realms.

KXOVER DEFINITIONS ::= BEGIN

IMPORTS PrincipalName, Realm, Authenticator, PA-DATA,
       KerberosTime, Int32, UInt32 FROM RFC4120

       Certificate, AlgorithmIdentifier, SubjectPublicKeyInfo,
       AuthorityKeyIdentifier FROM RFC5280;

-- A few definitions for readability, in line with RFC 4120:

EncryptionType   ::=  Int32
KeyVersionNumber ::= UInt32
Nonce            ::= UInt32


-- The `KX-REQ` and `KX-REP` messages are variations on the `AS-REQ` and `AS-REP`
-- messages, respectively.  Their underlying messages `KDC-REQ` and `KDC-REP` have
-- had to change, and we will refer to our modified versions with a `-MOD`
-- postfix.

KX-REQ ::= [APPLICATION 18] KDC-REQ-MOD

KX-REP ::= [APPLICATION 19] KDC-REP-MOD

-- The `KDC-REQ-MOD` is the modified KDC request for the `KX` exchange, but that
-- is kept as easy as possible to overlay with the original `KDC-REQ` format.
-- It chiefly carries PA-data holding the `KX` request.

KDC-REQ-MOD ::= SEQUENCE {
        -- NOTE: first tag is [1], not [0]
        pvno            [1] INTEGER (5) ,
        msg-type        [2] INTEGER (18) --KX--,
        padata          [3] SEQUENCE OF PA-DATA,
        reserved4       [4] ANY OPTIONAL  -- Ignored
}


-- The `KDC-REP-MOD` is the modified version of the `KDC-REP` for use with `KX`.
-- The most striking difference is that there is no `ticket` and no `enc-part`
-- field, because the only things setup is a key, and this is established through
-- an ECDH key exchange, which goes into the `padata` field.  So again, the message
-- chiefly serves to carry the KXOVER-specific `PA-DATA` field.

KDC-REP-MOD ::= SEQUENCE {
        pvno            [0] INTEGER (5),
        msg-type        [1] INTEGER (19) --KX--,
        padata          [2] SEQUENCE OF PA-DATA,
        reserved3       [3] ANY OPTIONAL, -- Ignored
        reserved4       [4] ANY OPTIONAL, -- Ignored
        reserved5       [5] ANY OPTIONAL, -- Ignored
        reserved6       [6] ANY OPTIONAL  -- Ignored
}

-- The fields that are marked to be `Ignored` should be sent as `NULL` for `KX`
-- between KDCs, but are expected to be useful in case a future expension is made
-- to include direct contact between clients and a KDC.  To facilitate this,
-- current `KX` implementations MUST NOT interpret these fields in any way, and
-- simply ignore their absense or, in case of presence, their contents.

-- One piece of `PA-DATA` must be included in the `padata` fields of both `KX-REQ`
-- and `KX-REP`, namely `pa-kx`, defined below.  This is the
-- only field that is interpreted when `KX` is used between KDCs.

--     padata-type    Name     Contents of padata-value
--     TBD:1234567    pa-kx    DER encoding of KX-PA-DATA


-- ## The "typed hole" filling for KXOVER
-- 
-- Since the purpose of KXOVER is to communicate with unrelated peers on the
-- Internet, the protocol is more constrained than general Kerberos.  For this
-- reason there is no facilitation of `KerberosFlags` and the "typed hole" of the
-- `padata` fields in `KX-REQ` and `KX-REP` are much more modest than in general
-- exchanges with the KDC of one's local realm.
-- 
-- Although inspired on PKINIT, the KXOVER exchange makes a few different choices:
-- 
--   * Key exchange with Forward Secrecy is always incorporated into the protocol.
--     Crossover keys between KDCs are suggested to last at least multiple days, with
--     a suggestion of two weeks.  We prefer to setup longer initial times over
--     introducing the code complexity of reusing previously agreed-upon keys.
-- 
--   * There is no support for Modular-Exponentiation Diffie-Hellman; there is support
--     for Elliptic-Curve Diffie-Hellman.
-- 
--   * We have removed the CMS notation.  The opportunity for reuse of CMS code in a
--     Kerberos context is not very high.  We have replaced it with similar
--     specification patterns as are used in the rest of Kerberos.
-- 
--   * We specify a KDC-to-KDC exchange, but leave room that we believe might be
--     supportive of a potential future client-to-KDC exchange.


-- The `KX-PA-DATA` structure contains signed information, the signature, information
-- to validate the signature, and a `nonce` field for fast resend discovery in the
-- transport layer.  Most of the signing structures are copied from their PKIX
-- counterparts.

KX-PA-DATA ::= SEQUENCE {

     -- Transport-level information:
        nonce           [0] Nonce,

     -- About the signature:
        signature-input [1] KX-PA-TBSDATA,
        signature-owner [2] SEQUENCE OF Certificate,

    --  The action signature:
        signature-alg   [3] AlgorithmIdentifier,
        signature-value [4] BIT STRING
}

-- In this structure:
-- 
--   * The `nonce` field holds a random value that should not be reused too quickly.
--     Its purpose is to match a `KX-REP` to a `KX-REQ`, as well as to detect resends
--     due to (assumed) network dropouts at the transport level.
-- 
--   * The `signature-input` contains the to-be-signed data for this half exchange.
--     Any data in here will be certain to have come from the signature owner.  The
--     field is DER-encoded and the signature applied to it will cover the contents
--     of this field alone; this starts with the tag and length for this field.
-- 
--   * The `signature-owner` field lists standard `Certificate` structures from
--     [RFC5280](http://tools.ietf.org/html/rfc5280#section-4.1),
--     in the order of a chain from the end certificate to a self-signed root
--     certificate.  The first certificate represents the KDC that constructed
--     this `KX-PA-DATA`, and it should conform to the Certificate Profile for KXOVER
--     below.  The root certificate is one that is assumed to be acceptable to
--     the intended recipient; if not, then further negotiation may be required.
--     Most importantly, the first certificate in the list must be confirmed through
--     DANE as specified below.
-- 
--   * The `signature-alg` field holds the algorithm used to sign the `KX-PA-TBSDATA`
--     contents, as defined in
--     [RFC5280](http://tools.ietf.org/html/rfc5280#section-4.1.1.2)
--     as a pair of an object identifier and optional parameters.
-- 
--   * The `signature-value` field holds the actual signature, according to the
--     outcome of the `signature-alg` field, and encoded just as the `signatureValue`
--     in a certificate, as defined in
--     [RFC5280](http://tools.ietf.org/html/rfc5280#section-4.1.1.3)
-- 

-- ## Signed Data for KXOVER

KX-PA-TBSDATA ::= SEQUENCE {

     -- Ensuring signature freshness / scattering:
        authenticator   [0] Authenticator,

     -- Key description information:
        kvno            [1] KeyVersionNumber,
        kxname          [2] PrincipalName,
        key-exchange    [3] SubjectPublicKeyInfo,

     -- Timing information:
        till            [4] KerberosTime,
        --DROPPED rtime [X] KerberosTime OPTIONAL,

     -- Negotiation terms in preference order:
        accept-etype    [5] SEQUENCE OF EncryptionType,
        accept-group    [6] SEQUENCE OF AlgorithmIdentifier OPTIONAL,
        accept-sigalg   [7] SEQUENCE OF AlgorithmIdentifier OPTIONAL,
        accept-ca       [8] SEQUENCE OF AuthorityKeyIdentifier OPTIONAL
}

-- The fields of this structure are defined as follows:
-- 
--   * The `authenticator` is used to scatter the signature, as well as to tie in a
--     timestamp.  Since signatures are assumed to be made on demand, the timing may
--     be assumed to be very close to the current wallclock time.  Note that KDCs are
--     already required to follow a timekeeping discipline, so this is no new
--     requirement.  The `Authenticator` structure is defined in
--     [RFC4120](https://tools.ietf.org/html/rfc4120#section-5.5.1)
--     and its optional fields are not used; the `crealm` and `cname` fields are not
--     important to `KX` between KDCs and may be set arbitrarily.  If a version of
--     `KX` is ever be devised to service clients directly, then the additional fields
--     in the `Authenticator` are expected to be useful.
-- 
--   * The `kvno` is a key version number as it is used in Kerberos' `EncryptedData`
--     [RFC4120](https://tools.ietf.org/html/rfc4120#section-5.2.9)
--     to help select a long-lasting key from among a set.  This is indeed what is
--     needed to facilitate key rollover, as documented below.  The `kvno` value
--     MUST be the same in the `KX-REQ` and `KX-REP` messages if the result of the
--     key exchange is to be setup on both ends.  When they differ, the KDCs
--     MUST NOT setup the key in their internal databases.
--
--   * The `kxname` is the desired principal name to setup with this exchange.  It
--     MUST be of the form `krbtgt/SERVICE.REALM@CLIENT.REALM` where the
--     `SERVICE.REALM` and `CLIENT.REALM` are placeholders for what their names
--     suggest.  The realm names should be validated against the certificates and
--     against DNS, as specified below.  The value of `kxname` set in the `KX-REQ`
--     and `KX-REP` MUST match.
-- 
--   * The `key-exchange` holds public key for key exchange to establish Forward Secrecy.
--     At present, this is constrained to Elliptic-Curve Diffie-Hellman keys such as
--     those defined in
--     [RFC5480](https://tools.ietf.org/html/rfc5480).
--     Note that both `KX-REQ` and `KX-REP` include the group; not only does this
--     keep the message format symmetric, but it also means that a service can make a
--     counter-proposal if it disagrees with a proposed ECDH group.
-- 
--   * The `till` field defines the latest time at which `TGS` requests based on this
--     key would be permitted.  Each side makes a proposal, but the key MUST NOT be
--     used across either sides' proposal, so effectively the `till` for an established
--     key is the earliest of the two proposed `till` time stamps.  The timing must
--     encapsulate the lifetime for user `Tickets`, so it should not be set to expire
--     sooner than a week in the future.  On the other hand, if negotiation fails and
--     only the service ends up with a key, it is nice to see it expire, so `till` times
--     offering more than 3 weeks are not advisable either.  We suggest 2 weeks as a
--     suitable default for `till` timing.  Note that it is possible to continue to
--     verify DNS on the credentials gathered to get to the key, in order to learn if it
--     may still be used.
-- 
--   * **DROPPED:** The `rtime` field was to define a renewal time.  It was dropped on
--     account of requiring the effort of a full `KX` handshake.  Renewals complicate
--     the `KX` procedure and do not seem to be really helpful.  A much better
--     opportunity appears to be refreshing the DNS data that was used for validation,
--     so as to detect the retraction of a certificate.
-- 
-- The remaining fields constitute negotiation, always as a list of values ordered
-- from most-preferred to least-preferred.  All these lists MUST NOT be empty.  In all
-- cases, the responding service KDC MAY include entries not sent by the initiating
-- client KDC, so as to suggest alternatives.
-- 
--   * The `accept-etype` field defines the encryption types that may be derived for
--     the ECDH shared key, once it is established.  Each side provides a list of
--     its possibilities, and the service's KDC  MUST create a realm crossover key
--     for each of encryption types that occurs in both lists.  Note that the
--     service is the responding party, and as such it can control which keys it
--     will actually create from the list offered by the client KDC.  The client KDC
--     MUST NOT construct TGTs for encryption types that were not in both the lists.
-- 
--   * The `accept-group` field contains acceptable `AlgorithmIdentifier` values for
--     key exchange with Forward Secrecy.  At present, the algorithms are limited to
--     Elliptic-Curve Diffie-Hellman algorithms.
-- 
--   * The `accept-sigalg` field indicates acceptable signature algorithms.
--     **TODO:** Is this the right thing in the right place at the right time?
--
--   * **TODO:** If so desired, we might also negotiate the hash algorithm used
--     over `KXOVER-KEY-INFO` below.
-- 
--   * The `accept-ca` field contains a list of certificate authority certificates
--     acceptable to the sender.  This can be used in situations that intend to
--     enforce the use of a public or private CA on top of the DNS-based validation
--     described below.  Applications include enforcing a federation.  Since a list
--     of CAs are supported, it is possible for KDCs to participate in more than one
--     federation at a time.  The CA is identified by an `AuthorityKeyIdentifier`
--     as defined in
--     [RFC5280](http://tools.ietf.org/html/rfc5280#section-4.2.1.1)
--     for purposes of this kind.
-- 


-- ## Establishing Crossover Keys
--
-- Realm crossover keys established with KXOVER can be derived from the shared secret
-- established by ECDH key exchange.  It is useful to have different keys for different
-- encryption types.  Since it is common to hash the outcome of an ECDH exchange, we
-- can use that time to hash in a few other things.
-- 
-- The hash algorithm is not a primary security concern, as the shared key is already
-- well-protecting (its bits only need a good shuffle) and the outcome is not made
-- publicly visible either.  Based on this observation, we choose a fixed algorithm,
-- namely SHA-256, and compute a series of hashes as long as needed for the key
-- material desired by the targeted encryption type.
--
-- The data to be hashed is the DER encoding of the `KXOVER-KEY-INFO` structure
-- defined below.


KXOVER-KEY-INFO ::= SEQUENCE {
        kxover-name     [0] IA5String --("KXOVER")--,   -- fixed string "KXOVER"
        seq-nr          [1] INTEGER --(1..)--,          -- hash index counter (1..)
        kxname          [2] PrincipalName,              -- from KX-PA-TBSDATA
        till            [3] KerberosTime,               -- from KX-PA-TBSDATA
        kvno            [4] KeyVersionNumber,           -- from KX-PA-TBSDATA
        etype           [5] EncryptionType,             -- from KX-PA-TBSDATA
        shared-key      [6] OCTET STRING                -- the value Z
}

-- The value `kxover-name` is a fixed string, the `kxname` and `kvno` values are
-- taken from the `KX-PA-TBSDATA`; these values are the same in both directions.
-- The `till` value represents the earlies of the two values in `KX-REQ` and `KX-REP`.
-- The `enc-type` is a value that has occurred in the `accept-etype` field in both
-- the `KX-REQ` and `KX-REP`.  There may be multiple that occur in both, and each
-- leads to a different structure and a different hash value.
-- The value of `shared-key` is the value that usually referred to as Z, and is
-- included as a raw OCTET STRING; leading zero bytes are not removed.

-- A virtually infinite sequence of SHA-256 computations can be constructed from
-- this structure by starting with `seq-nr` set to 1, and incrementing it for each
-- new has computation.  The concatenated hashed results form a sequence of bytes
-- that reflect the entropy of the `KXOVER-KEY-INFO` structure and, more specifically,
-- of the `shared-key` contained in it.  A prefix from this sequence is taken to
-- provide the targeted encryption type, as mentioned in the `etype` field, with
-- a raw symmetric key.  This key will be inserted on both the client's and the
-- service's KDC with its name set to `kxname`.


-- ## Key Rollover between KDCs
--
-- The `KX` exchange establishes shared keys for a certain time.  Based on these keys,
-- the client KDC can construct Ticket Granting Tickets that last for one user session.
-- At some point near the end of the lifetime of the realm crossover key however,
-- it may not be possible to supply keys to users that last long enough, and there
-- is a need to rerun the `KX` exchange.  After the new key is established, there
-- will be previously supplied clients using the old key and others using the new key.
--
-- To handle this overlap of keys properly, there is a `kvno` field in the
-- `KX-PA-TBSDATA` structure that is setup with the express intent to identify to
-- the service's KDC's crossover key.  The client's KDC MUST NOT provide clients
-- with Ticket Granting Tickets for the service's KDC that expire after the earliest
-- `till` time, and the service's KDC MUST NOT remove the crossover key before the
-- earliest `till` time.
--
-- When sending a Ticket Granting Ticket to a client that addresses a service KDC
-- whose crossover key was established through KXOVER, then the client KDC MUST
-- include a suitable `kvno` field in the `EncryptedData` structure of that
-- Ticket Granting Ticket.


-- ## Certificate Profile for KXOVER
--
-- To facilitate the `KX` exchange, a KDC needs a certificate under the following
-- constraints:
--
--   * The certificate holds a *realm set* name to claim its realm names; this MUST
--     contain the `CLIENT.NAME` part of the `kxname` when the certificate is used to
--     sign for a `KX-REQ`; and it MUST contain the `SERVICE.NAME` part of the
--     `kxname` when the certificate is used to sign for a `KX-REP`.  Note that
--     it is possible for additional realms to be contained, which is quite
--     acceptable, and only presence of the realm from the `kxname` is assured.
--
--   * The certificate holds an Extended Key Usage OIDs as defined in
--     [RFC5280](http://tools.ietf.org/html/rfc5280#section-4.2.1.12)
--     to indicate support for `KX`; for the certificate signing the `KX-REQ`,
--     the OIDs MUST include `id-kxover-kdc-service`; for the certificate signing the
--     `KX-REP`, the OIDs MUST include `id-kxover-kdc-client`.  It is possible and
--     even likely for general-purpose KDCs to use certificates that hold both OIDs,
--     so they can be used in each direction.
--
-- Certificates that supply this information properly are considered acceptable
-- signers, but validating their signatures involves more validation steps:
--
--   * The certificate chain in `signature-owner` is acknowledged by the DNS-based
--     validation procedure described below; this is the pivotal step that makes
--     it possible to perform impromptu realm crossover.
--
--   * The validation of the certificate chain in `signature-owner` MUST succeed.
--
--   * Local policy MAY require additional interrogation of CRLs, OCSP and so on.
--
--   * Local policy MAY restrict the last certificate in the `signature-owner` chain
--     to be one of a list of accepted CAs.
--

-- The *realm set* extension is a value in the `subjectAltName` extension
-- [RFC5280](http://tools.ietf.org/html/rfc5280#section-4.2.1.6) which
-- holds a set of realm names that the KDC claims to administer; the extension
-- is of the form `OtherName`, with `type-id` set to `id-kxover-krb5realm` and
-- `value` set to the `KRB5RealmSet` structure defined below:

id-kxover-krb5realmset OBJECT IDENTIFIER ::= {
        1 3 6 1 4 1 arpa2(44469) experimental(666) kerberos(88) kxover(1)
        san(2) realmset(1) }

KRB5RealmSet ::= SET OF Realm

-- The OIDs representing the Extended Key Usage patterns of KXOVER are:

id-kxover-kdc-service OBJECT IDENTIFIER ::= {
        1 3 6 1 4 1 arpa2(44469) experimental(666) kerberos(88) kxover(1)
        role(1) kdc-service(0) }

id-kxover-kdc-client OBJECT IDENTIFIER ::= {
        1 3 6 1 4 1 arpa2(44469) experimental(666) kerberos(88) kxover(1)
        role(1) kdc-client(1) }

id-kxover-princ-service OBJECT IDENTIFIER ::= {
        1 3 6 1 4 1 arpa2(44469) experimental(666) kerberos(88) kxover(1)
        role(1) princ-service(2) }

id-kxover-princ-client OBJECT IDENTIFIER ::= {
        1 3 6 1 4 1 arpa2(44469) experimental(666) kerberos(88) kxover(1)
        role(1) princ-client(3) }


-- ## DNS-based Validation
--
-- DNS-based validation is the one requirement that MUST be met for all certificates
-- used in the KXOVER framework.  This permits the current habit of KDC-local CAs
-- that can be connected through validation with DNSSEC and DANE.  These technologies
-- are based on public-key cryptography under control of DNS infrastructure operators.
--
-- The two sides validate each other, by looking up DANE information in DNS, checking
-- DNSSEC signatures to be present and correct, and only when this is the case will
-- they consider a signer's certificate acceptable, and as a result, the supplied
-- `KX-PA-TBSDATA` contents.
--
-- The result of this is a framework of authenticity.  The built-in ECDH mechanism
-- is also authenticated, leading to the setup of a shared key between the end points,
-- which can be used locally as a realm crossover key on which Ticket Granting Tickets
-- can be based.
--
-- The method in which the client's KDC establishes the realm to which it needs to
-- crossover is considered to fall outside the scope of this specification.
--
-- When a KDC (referred to below as the *validating KDC*) wants to validate another,
-- (referred to as the *evaluated KDC*) for which it has a claimed realm (the
-- *evaluated realm*), it proceeds as follows:
--
--  1. Demanding DNSSEC for security, the validating KDC extracts an `SRV` record
--     under the DNS-mapped name of the evaluated realm, to find the address and port
--     of the evaluated KDC.  This is considered the authoritative information for
--     the evaluated realm, and leading for identifying key material.  This is so
--     strong that there is no requirement to verify the address and port information
--     against incoming requests.  **TODO: DISCUSSION TOPIC:**  It may be useful to have
--     a daemon that runs separately from the KDC; this will use another port; it may
--     also use another address/family?
--
--  2. Demanding DNSSEC for security, the validating KDC extracts the TLSA records
--     for the evaluated KDC service.
--
--  3. Upon arrival of the `KX-PA-DATA` structure from the other side, the TLSA
--     record data is used to validate the `signature-owner` chain of certificates.
--
--  4. Either through backtracking or composing sets of alternatives, any places
--     where the DNS supplies multiple values it will be seen as alternative ways
--     of establishing the desired certainty.



END
